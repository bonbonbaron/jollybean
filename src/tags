!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BBSeed	botox/include/bt.h	/^} BBSeed;$/;"	t	typeref:struct:__anon34
BBSeed_	botox/include/bt.h	8;"	d
BLACKBOARD	framework/include/xMain.h	/^typedef enum {ECS_COMPONENT, ECS_SHARED, BLACKBOARD} GeneClass;$/;"	e	enum:__anon21
BOTOX_H	botox/include/botox.h	2;"	d
BT_H	botox/include/bt.h	2;"	d
BTree	botox/include/bt.h	/^} BTree;  $/;"	t	typeref:struct:__anon36
BTreeSingleton	botox/include/bt.h	/^} BTreeSingleton;$/;"	t	typeref:struct:__anon37
BTreeSingleton_	botox/include/bt.h	99;"	d
Biome	framework/include/xMain.h	/^} Biome;$/;"	t	typeref:struct:__anon25
Biome_	framework/include/xMain.h	5;"	d
Blackboard	botox/include/bt.h	/^} Blackboard;$/;"	t	typeref:struct:__anon35
Bln	botox/include/data.h	/^typedef U8 Bln;   \/\/ Boolean$/;"	t
COMPLETE	botox/include/bt.h	/^typedef enum {READY, RUNNING, COMPLETE, FAILED, ERROR} NodeStat;$/;"	e	enum:__anon33
CTRL_A	xBuiltins/include/xControl.h	20;"	d
CTRL_B	xBuiltins/include/xControl.h	21;"	d
CTRL_DOWN	xBuiltins/include/xControl.h	19;"	d
CTRL_LEFT	xBuiltins/include/xControl.h	16;"	d
CTRL_LISTEN	xBuiltins/include/xControl.h	/^	CTRL_LISTEN = 1$/;"	e	enum:__anon1
CTRL_RIGHT	xBuiltins/include/xControl.h	17;"	d
CTRL_SELECT	xBuiltins/include/xControl.h	23;"	d
CTRL_START	xBuiltins/include/xControl.h	22;"	d
CTRL_UP	xBuiltins/include/xControl.h	18;"	d
Check	botox/include/x.h	/^} Check;$/;"	t	typeref:struct:__anon50
CheckCBP	botox/include/x.h	/^typedef Bln (*CheckCBP)(XHeader *xhP, void *operandP);$/;"	t
Checkers	botox/include/x.h	/^} Checkers;$/;"	t	typeref:struct:__anon51
Color_	engine/include/jbInterface.h	6;"	d
Colormap	xBuiltins/include/xRender.h	/^} Colormap;     \/\/ When the inflatable requires neither unpacking nor strip-mapping, go ahead and memcpy over. I can't think of any cleaner way to do it.$/;"	t	typeref:struct:__anon8
CompLocation	botox/include/x.h	/^} CompLocation;$/;"	t	typeref:struct:__anon48
DATA_H	botox/include/data.h	2;"	d
ECS_COMPONENT	framework/include/xMain.h	/^typedef enum {ECS_COMPONENT, ECS_SHARED, BLACKBOARD} GeneClass;$/;"	e	enum:__anon21
ECS_SHARED	framework/include/xMain.h	/^typedef enum {ECS_COMPONENT, ECS_SHARED, BLACKBOARD} GeneClass;$/;"	e	enum:__anon21
ERROR	botox/include/bt.h	/^typedef enum {READY, RUNNING, COMPLETE, FAILED, ERROR} NodeStat;$/;"	e	enum:__anon33
E_BAD_ARGS	botox/include/data.h	/^	E_BAD_ARGS,$/;"	e	enum:Error
E_BAD_INDEX	botox/include/data.h	/^	E_BAD_INDEX,$/;"	e	enum:Error
E_BAD_KEY	botox/include/data.h	/^	E_BAD_KEY,$/;"	e	enum:Error
E_MAILBOX_FULL	botox/include/data.h	/^	E_MAILBOX_FULL$/;"	e	enum:Error
E_MSG_INVALID_CMD	botox/include/data.h	/^	E_MSG_INVALID_CMD,$/;"	e	enum:Error
E_MSG_TO_ECS_TYPE_MISMATCH	botox/include/data.h	/^	E_MSG_TO_ECS_TYPE_MISMATCH,$/;"	e	enum:Error
E_MSG_TO_ID_MISMATCH	botox/include/data.h	/^	E_MSG_TO_ID_MISMATCH,$/;"	e	enum:Error
E_NO_MEMORY	botox/include/data.h	/^	E_NO_MEMORY,$/;"	e	enum:Error
E_NULL_VAR	botox/include/data.h	/^	E_NULL_VAR,$/;"	e	enum:Error
E_SYS_CMP_MISMATCH	botox/include/data.h	/^	E_SYS_CMP_MISMATCH,$/;"	e	enum:Error
E_UNEXPECTED_DCMP_SZ	botox/include/data.h	/^	E_UNEXPECTED_DCMP_SZ,$/;"	e	enum:Error
E_UNSUPPORTED_PIXEL_FORMAT	botox/include/data.h	/^	E_UNSUPPORTED_PIXEL_FORMAT,$/;"	e	enum:Error
Entity	botox/include/x.h	/^typedef Key Entity;$/;"	t
EnumValPair	botox/include/data.h	/^} EnumValPair;$/;"	t	typeref:struct:__anon38
Error	botox/include/data.h	/^typedef enum Error {$/;"	g
Error	botox/include/data.h	/^} Error;$/;"	t	typeref:enum:Error
Event	engine/include/jbInterface.h	16;"	d
FAILED	botox/include/bt.h	/^typedef enum {READY, RUNNING, COMPLETE, FAILED, ERROR} NodeStat;$/;"	e	enum:__anon33
FlagInfo	botox/include/data.h	/^} FlagInfo;$/;"	t	typeref:struct:__anon40
FlipSet	xBuiltins/include/xRender.h	/^} FlipSet;$/;"	t	typeref:struct:__anon5
Focus	botox/include/x.h	/^} Focus;$/;"	t	typeref:struct:_Focus
FocusFP	botox/include/x.h	/^typedef Error (*FocusFP)(struct _Focus *aP);$/;"	t
FocusLocation	botox/include/x.h	/^} FocusLocation;$/;"	t	typeref:struct:__anon49
Focus_	botox/include/x.h	38;"	d
GeneClass	framework/include/xMain.h	/^typedef enum {ECS_COMPONENT, ECS_SHARED, BLACKBOARD} GeneClass;$/;"	t	typeref:enum:__anon21
GeneHeader	framework/include/xMain.h	/^} GeneHeader;$/;"	t	typeref:struct:__anon22
GeneHisto	framework/xMain.c	/^} GeneHisto;$/;"	t	typeref:struct:__anon13	file:
Genome	framework/include/xMain.h	/^} Genome;$/;"	t	typeref:struct:__anon23
Genome_	framework/include/xMain.h	10;"	d
HardCodedArray	botox/include/data.h	/^} HardCodedArray;$/;"	t	typeref:struct:__anon39
HardCodedArray_	botox/include/data.h	63;"	d
HardCodedMap	botox/include/data.h	/^} HardCodedMap;$/;"	t	typeref:struct:__anon43
HardCodedMap_	botox/include/data.h	81;"	d
Image	xBuiltins/include/xRender.h	/^} Image; $/;"	t	typeref:struct:__anon9
Inflatable	botox/include/data.h	/^} Inflatable;$/;"	t	typeref:struct:__anon44
JB_	engine/include/jb.h	2;"	d
JB_INTERFACE	engine/include/jbInterface.h	2;"	d
KEY_DOWN_	engine/include/jbInterface.h	21;"	d
KEY_ESCAPE	engine/include/jbInterface.h	51;"	d
KEY_LSHIFT	engine/include/jbInterface.h	50;"	d
KEY_SPACE	engine/include/jbInterface.h	49;"	d
KEY_UP_	engine/include/jbInterface.h	20;"	d
KEY_a	engine/include/jbInterface.h	23;"	d
KEY_b	engine/include/jbInterface.h	24;"	d
KEY_c	engine/include/jbInterface.h	25;"	d
KEY_d	engine/include/jbInterface.h	26;"	d
KEY_e	engine/include/jbInterface.h	27;"	d
KEY_f	engine/include/jbInterface.h	28;"	d
KEY_g	engine/include/jbInterface.h	29;"	d
KEY_h	engine/include/jbInterface.h	30;"	d
KEY_i	engine/include/jbInterface.h	31;"	d
KEY_j	engine/include/jbInterface.h	32;"	d
KEY_k	engine/include/jbInterface.h	33;"	d
KEY_l	engine/include/jbInterface.h	34;"	d
KEY_m	engine/include/jbInterface.h	35;"	d
KEY_n	engine/include/jbInterface.h	36;"	d
KEY_o	engine/include/jbInterface.h	37;"	d
KEY_p	engine/include/jbInterface.h	38;"	d
KEY_q	engine/include/jbInterface.h	39;"	d
KEY_r	engine/include/jbInterface.h	40;"	d
KEY_s	engine/include/jbInterface.h	41;"	d
KEY_t	engine/include/jbInterface.h	42;"	d
KEY_u	engine/include/jbInterface.h	43;"	d
KEY_v	engine/include/jbInterface.h	44;"	d
KEY_w	engine/include/jbInterface.h	45;"	d
KEY_x	engine/include/jbInterface.h	46;"	d
KEY_y	engine/include/jbInterface.h	47;"	d
KEY_z	engine/include/jbInterface.h	48;"	d
Key	botox/include/data.h	/^typedef U8 Key;$/;"	t
KeyValPair	botox/include/data.h	/^} KeyValPair;$/;"	t	typeref:struct:__anon41
LAST_FLAG_BYTE_IDX	botox/include/data.h	19;"	d
LeafNode_	botox/include/bt.h	47;"	d
MINIZ_HAS_64BIT_REGISTERS	botox/data.c	407;"	d	file:
MINIZ_LITTLE_ENDIAN	botox/data.c	402;"	d	file:
MINIZ_USE_UNALIGNED_LOADS_AND_STORES	botox/data.c	400;"	d	file:
MZ_CLEAR_OBJ	botox/data.c	529;"	d	file:
MZ_FREE	botox/data.c	519;"	d	file:
MZ_FREE	botox/data.c	523;"	d	file:
MZ_MACRO_END	botox/data.c	412;"	d	file:
MZ_MACRO_END	botox/data.c	414;"	d	file:
MZ_MALLOC	botox/data.c	518;"	d	file:
MZ_MALLOC	botox/data.c	522;"	d	file:
MZ_MAX	botox/data.c	527;"	d	file:
MZ_MIN	botox/data.c	528;"	d	file:
MZ_READ_LE16	botox/data.c	532;"	d	file:
MZ_READ_LE16	botox/data.c	535;"	d	file:
MZ_READ_LE32	botox/data.c	533;"	d	file:
MZ_READ_LE32	botox/data.c	536;"	d	file:
MZ_REALLOC	botox/data.c	520;"	d	file:
MZ_REALLOC	botox/data.c	524;"	d	file:
Mailbox	botox/include/data.h	/^} Mailbox;$/;"	t	typeref:struct:__anon46
Map	botox/include/data.h	/^} Map;$/;"	t	typeref:struct:__anon42
Message	botox/include/data.h	/^} Message;  $/;"	t	typeref:struct:__anon45
NO_CHILDREN	botox/include/bt.h	5;"	d
NO_SIBLINGS_LEFT	botox/include/bt.h	6;"	d
N_FLAG_BITS	botox/include/data.h	20;"	d
N_FLAG_BYTES	botox/include/data.h	18;"	d
Node	botox/include/bt.h	/^typedef struct Node {$/;"	s
Node	botox/include/bt.h	/^} Node;$/;"	t	typeref:struct:Node
NodeA	botox/include/bt.h	/^typedef struct NodeA {$/;"	s
NodeA	botox/include/bt.h	/^} NodeA;$/;"	t	typeref:struct:NodeA
NodeCb	botox/include/bt.h	/^typedef NodeStat (*NodeCb)(struct Node *rootP, struct Node *currNodeP, Blackboard *bbP, Mailbox *outboxP);  $/;"	t
NodeStat	botox/include/bt.h	/^typedef enum {READY, RUNNING, COMPLETE, FAILED, ERROR} NodeStat;$/;"	t	typeref:enum:__anon33
Node_	botox/bt.c	/^Node_(btSelector) {$/;"	f
Node_	botox/bt.c	/^Node_(btSequence) {$/;"	f
Node_	botox/bt.c	/^Node_(btXCondition) {$/;"	f
Node_	botox/bt.c	/^static Node_(_nodeRun) {$/;"	f	file:
Node_	botox/include/bt.h	72;"	d
Palette_	engine/include/jbInterface.h	12;"	d
Personality	framework/include/xGo.h	/^} Personality;$/;"	t	typeref:struct:__anon15
Personality_	framework/include/xGo.h	21;"	d
QUIT_	engine/include/jbInterface.h	18;"	d
Quirk	framework/include/xGo.h	/^} Quirk;$/;"	t	typeref:struct:__anon14
Quirk_	framework/include/xGo.h	6;"	d
READY	botox/include/bt.h	/^typedef enum {READY, RUNNING, COMPLETE, FAILED, ERROR} NodeStat;$/;"	e	enum:__anon33
RUNNING	botox/include/bt.h	/^typedef enum {READY, RUNNING, COMPLETE, FAILED, ERROR} NodeStat;$/;"	e	enum:__anon33
Reaction	framework/include/xGo.h	/^} Reaction;$/;"	t	typeref:struct:__anon17
Rect_	engine/include/jbInterface.h	7;"	d
Renderer_	engine/include/jbInterface.h	10;"	d
S16	botox/include/data.h	/^typedef short S16;$/;"	t
S32	botox/include/data.h	/^typedef int S32;$/;"	t
S8	botox/include/data.h	/^typedef char S8;$/;"	t
SUCCESS	botox/include/data.h	/^	SUCCESS,$/;"	e	enum:Error
SYS_CONTROL	xBuiltins/include/xControl.h	2;"	d
SYS_RENDER	xBuiltins/include/xRender.h	2;"	d
Seed	framework/include/xMain.h	/^} Seed;$/;"	t	typeref:struct:__anon24
SelectorNode_	botox/include/bt.h	55;"	d
SequenceNode_	botox/include/bt.h	63;"	d
SrcNode	botox/include/bt.h	/^typedef struct SrcNode {$/;"	s
SrcNode	botox/include/bt.h	/^} SrcNode;$/;"	t	typeref:struct:SrcNode
StripMap	xBuiltins/include/xRender.h	/^} StripMap;$/;"	t	typeref:struct:__anon7
StripSet	xBuiltins/include/xRender.h	/^} StripSet;$/;"	t	typeref:struct:__anon6
Surface_	engine/include/jbInterface.h	11;"	d
System	botox/include/x.h	/^} System;$/;"	t	typeref:struct:_System
System_	botox/include/x.h	21;"	d
TINFL_BITBUF_SIZE	botox/data.c	493;"	d	file:
TINFL_BITBUF_SIZE	botox/data.c	496;"	d	file:
TINFL_CR_BEGIN	botox/data.c	542;"	d	file:
TINFL_CR_FINISH	botox/data.c	545;"	d	file:
TINFL_CR_RETURN	botox/data.c	543;"	d	file:
TINFL_CR_RETURN_FOREVER	botox/data.c	544;"	d	file:
TINFL_DECOMPRESS_MEM_TO_MEM_FAILED	botox/data.c	442;"	d	file:
TINFL_FAST_LOOKUP_BITS	botox/data.c	/^  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS$/;"	e	enum:__anon31	file:
TINFL_FAST_LOOKUP_SIZE	botox/data.c	/^  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS$/;"	e	enum:__anon31	file:
TINFL_FLAG_COMPUTE_ADLER32	botox/data.c	/^  TINFL_FLAG_COMPUTE_ADLER32 = 8$/;"	e	enum:__anon29	file:
TINFL_FLAG_HAS_MORE_INPUT	botox/data.c	/^  TINFL_FLAG_HAS_MORE_INPUT = 2,$/;"	e	enum:__anon29	file:
TINFL_FLAG_PARSE_ZLIB_HEADER	botox/data.c	/^  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,$/;"	e	enum:__anon29	file:
TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF	botox/data.c	/^  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,$/;"	e	enum:__anon29	file:
TINFL_GET_BITS	botox/data.c	567;"	d	file:
TINFL_GET_BYTE	botox/data.c	549;"	d	file:
TINFL_HEADER_INCLUDED	botox/data.c	389;"	d	file:
TINFL_HUFF_BITBUF_FILL	botox/data.c	573;"	d	file:
TINFL_HUFF_DECODE	botox/data.c	592;"	d	file:
TINFL_LZ_DICT_SIZE	botox/data.c	453;"	d	file:
TINFL_MAX_HUFF_SYMBOLS_0	botox/data.c	/^  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,$/;"	e	enum:__anon31	file:
TINFL_MAX_HUFF_SYMBOLS_1	botox/data.c	/^  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,$/;"	e	enum:__anon31	file:
TINFL_MAX_HUFF_SYMBOLS_2	botox/data.c	/^  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,$/;"	e	enum:__anon31	file:
TINFL_MAX_HUFF_TABLES	botox/data.c	/^  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,$/;"	e	enum:__anon31	file:
TINFL_MEMCPY	botox/data.c	539;"	d	file:
TINFL_MEMSET	botox/data.c	540;"	d	file:
TINFL_NEED_BITS	botox/data.c	565;"	d	file:
TINFL_SKIP_BITS	botox/data.c	566;"	d	file:
TINFL_STATUS_ADLER32_MISMATCH	botox/data.c	/^  TINFL_STATUS_ADLER32_MISMATCH = -2,$/;"	e	enum:__anon30	file:
TINFL_STATUS_BAD_PARAM	botox/data.c	/^  TINFL_STATUS_BAD_PARAM = -3,$/;"	e	enum:__anon30	file:
TINFL_STATUS_DONE	botox/data.c	/^  TINFL_STATUS_DONE = 0,$/;"	e	enum:__anon30	file:
TINFL_STATUS_FAILED	botox/data.c	/^  TINFL_STATUS_FAILED = -1,$/;"	e	enum:__anon30	file:
TINFL_STATUS_HAS_MORE_OUTPUT	botox/data.c	/^  TINFL_STATUS_HAS_MORE_OUTPUT = 2$/;"	e	enum:__anon30	file:
TINFL_STATUS_NEEDS_MORE_INPUT	botox/data.c	/^  TINFL_STATUS_NEEDS_MORE_INPUT = 1,$/;"	e	enum:__anon30	file:
TINFL_USE_64BIT_BITBUF	botox/data.c	488;"	d	file:
Texture_	engine/include/jbInterface.h	8;"	d
U16	botox/include/data.h	/^typedef unsigned short U16;$/;"	t
U32	botox/include/data.h	/^typedef unsigned int U32;$/;"	t
U8	botox/include/data.h	/^typedef unsigned char U8;$/;"	t
Window_	engine/include/jbInterface.h	9;"	d
XClrFP	botox/include/x.h	/^typedef Error (*XClrFP)(struct _System *sP);$/;"	t
XControl	xBuiltins/include/xControl.h	/^} XControl;$/;"	t	typeref:struct:__anon3
XControlComp	xBuiltins/include/xControl.h	/^} XControlComp;$/;"	t	typeref:struct:__anon2
XControlFocusID	xBuiltins/include/xControl.h	/^} XControlFocusID;$/;"	t	typeref:enum:__anon1
XGo	framework/include/xGo.h	/^} XGo;$/;"	t	typeref:struct:__anon20
XGoComp	framework/include/xGo.h	/^} XGoComp;$/;"	t	typeref:struct:__anon16
XGoIniSeed	framework/include/xGo.h	/^} XGoIniSeed;$/;"	t	typeref:struct:__anon18
XGoIniSeedPkg	framework/include/xGo.h	/^} XGoIniSeedPkg;$/;"	t	typeref:struct:__anon19
XHeader	botox/include/x.h	/^} XHeader;$/;"	t	typeref:struct:__anon47
XHistoElem	framework/xMain.c	/^} XHistoElem;$/;"	t	typeref:struct:__anon12	file:
XIniCompFP	botox/include/x.h	/^typedef Error (*XIniCompFP)(struct _System *sP, XHeader *xhP);$/;"	t
XIniSFP	botox/include/x.h	/^typedef Error (*XIniSFP)(struct _System *sP, void* sParamsP);$/;"	t
XMAIN_	framework/include/xMain.h	2;"	d
XMain	framework/include/xMain.h	/^} XMain;$/;"	t	typeref:struct:__anon28
XMainComp	framework/include/xMain.h	/^typedef System XMainComp;$/;"	t
XMainIniSysPrms	framework/include/xMain.h	/^} XMainIniSysPrms;$/;"	t	typeref:struct:__anon27
XProcMsgFP	botox/include/x.h	/^typedef Error (*XProcMsgFP)(struct _System *sP, Message *messageP);$/;"	t
XRENDER	xBuiltins/include/xRender.h	/^	XRENDER = 1$/;"	e	enum:__anon4
XRender	xBuiltins/include/xRender.h	/^} XRender;$/;"	t	typeref:struct:__anon11
XRenderComp	xBuiltins/include/xRender.h	/^} XRenderComp;$/;"	t	typeref:struct:__anon10
XRenderFocusID	xBuiltins/include/xRender.h	/^} XRenderFocusID;$/;"	t	typeref:enum:__anon4
XRenderPresentFP	xBuiltins/include/xRender.h	/^typedef void (*XRenderPresentFP)(Renderer_ *rendererP);$/;"	t
X_	botox/include/x.h	12;"	d
X_GO	framework/include/xGo.h	2;"	d
X_H	botox/include/x.h	2;"	d
_Focus	botox/include/x.h	/^typedef struct _Focus {$/;"	s
_System	botox/include/x.h	/^typedef struct _System {$/;"	s
_arrayGetVoidElemPtr	botox/data.c	/^inline static void* _arrayGetVoidElemPtr(const void *arryP, S32 idx) {$/;"	f	file:
_cmClr	xBuiltins/xRender.c	/^void _cmClr(Colormap *cmP) {$/;"	f
_cmGen	xBuiltins/xRender.c	/^Error _cmGen(Colormap *cmP) {$/;"	f
_countBits	botox/data.c	/^inline static U8 _countBits(Key bitfield) {$/;"	f	file:
_countNodes	botox/bt.c	/^static U16 _countNodes(Node *rootP, Node *startFromNodeP) {$/;"	f	file:
_countSpecificNodes	botox/bt.c	/^static U16 _countSpecificNodes(Node *rootP, Node *startFromNodeP, NodeCb nodeCb) {$/;"	f	file:
_countSrcNodes	botox/bt.c	/^static U16 _countSrcNodes(SrcNode *nodeP) {$/;"	f	file:
_distributeGenes	framework/xMain.c	/^static Error _distributeGenes(XMain *xMainSysP, Key nSystemsMax) {$/;"	f	file:
_distributeHiveMinds	framework/xGo.c	/^static Error _distributeHiveMinds(XGo *xGoSysP, XGoIniSeedPkg *seedPkgP) {$/;"	f	file:
_elemSz	botox/include/data.h	/^	Key        _elemSz;$/;"	m	struct:__anon43
_elemSz	botox/include/data.h	/^	U32         _elemSz;$/;"	m	struct:__anon39
_enum	botox/include/data.h	/^	Key _enum;$/;"	m	struct:__anon38
_fast_arrayGetElemSz	botox/data.c	/^static inline U32 _fast_arrayGetElemSz(const void *arryP) {$/;"	f	file:
_fast_arrayGetVoidElemPtr	botox/data.c	/^static inline void* _fast_arrayGetVoidElemPtr(const void *arryP, U8 idx) {$/;"	f	file:
_getCompLocation	botox/x.c	/^inline static CompLocation* _getCompLocation(System *sP, Entity entity) {$/;"	f	file:
_getCompPByIdx	botox/x.c	/^inline static void* _getCompPByIdx(Focus *fP, U8 compIdx) {$/;"	f	file:
_getE	botox/x.c	/^inline static Entity _getE(const void *cmpP) {$/;"	f	file:
_getElemIdx	botox/data.c	/^inline static U32 _getElemIdx(const FlagInfo f, const Key key) {$/;"	f	file:
_getElemP	botox/data.c	/^inline static void* _getElemP(const Map *mapP, const FlagInfo f, const Key key) {$/;"	f	file:
_getFlagInfo	botox/data.c	/^inline static FlagInfo _getFlagInfo(const Map *mapP, const Key key) {$/;"	f	file:
_getFocusLocation	botox/x.c	/^inline static FocusLocation* _getFocusLocation(System *sP, Key focusID) {$/;"	f	file:
_getMapElemSz	botox/data.c	/^inline static U32 _getMapElemSz(const Map *mapP) {$/;"	f	file:
_getNBitsSet	botox/data.c	/^inline static U32 _getNBitsSet(const Map *mapP) {$/;"	f	file:
_histoGeneTypes	framework/xMain.c	/^static Error _histoGeneTypes(GeneHisto *geneHistoP, Biome *biomeP) {$/;"	f	file:
_histoHiveMindTriggers	framework/xGo.c	/^static Error _histoHiveMindTriggers(U32 **histoAP, XGoIniSeedPkg *seedPkgP, U32 *totalDistinctHiveMindsP) {$/;"	f	file:
_idxIsPopulated	botox/data.c	/^inline static U8 _idxIsPopulated(const U32 nBitsSet, U32 idx) {$/;"	f	file:
_iniCondKeys	botox/bt.c	/^static Error _iniCondKeys(Node *rootP, Node *startFromNodeP, NodeCb nodeCb, Map *mapP) {$/;"	f	file:
_isFlagSet	botox/data.c	/^inline static U8 _isFlagSet(const U8 flags, const Key key) {$/;"	f	file:
_isHigherPriority	framework/xGo.c	/^inline static U8 _isHigherPriority(U8 newPriority, U8 existingPriority) {$/;"	f	file:
_isKeyValid	botox/data.c	/^inline static U8 _isKeyValid(const Key key) {$/;"	f	file:
_isMapValid	botox/data.c	/^inline static U8 _isMapValid(const Map *mapP) {$/;"	f	file:
_mvC	botox/x.c	/^static Error _mvC(System *sP, void *srcCP, void *dstCP, Key dstFocusID, U8 dstCIdx) {$/;"	f	file:
_mvFocus	botox/x.c	/^static Error _mvFocus(Focus *srcFocusP, U8 dstFocusIdx) {$/;"	f	file:
_nEnumValPairs	botox/include/data.h	/^	U32         _nEnumValPairs;$/;"	m	struct:__anon39
_nKeyValPairs	botox/include/data.h	/^	Key        _nKeyValPairs;$/;"	m	struct:__anon43
_nodePush	botox/bt.c	/^static void _nodePush(SrcNode *srcNodeP, Node *rootP, U8 *nextAvailIdxP) {$/;"	f	file:
_padding_	framework/include/xMain.h	/^	U8 _padding_;$/;"	m	struct:__anon22
_swapFocuses	botox/x.c	/^static Error _swapFocuses(Focus *fP, U8 dstFocusIdx) {$/;"	f	file:
_triggerHiveMind	framework/xGo.c	/^static Error _triggerHiveMind(XGo *xGoSysP, Message *msgP) {$/;"	f	file:
_triggerIndividual	framework/xGo.c	/^static Error _triggerIndividual(XGo *xGoSysP, Message *msgP) {$/;"	f	file:
_updateCompLocation	botox/x.c	/^static Error  _updateCompLocation(System *sP, Entity entity, U8 dstFocusID, U8 dstCIdx, void *dstCP) {$/;"	f	file:
_updateFocusLocation	botox/x.c	/^static Error _updateFocusLocation(System *sP, Key focusID, U8 dstFocusIdx, Focus *dstFocusP) {$/;"	f	file:
_validateFocusIdx	botox/x.c	/^inline static U8 _validateFocusIdx(const System *sP, const U8 focusIdx) { $/;"	f	file:
_xClrFocuses	botox/x.c	/^static void _xClrFocuses(System *sP) {$/;"	f	file:
_xReadInbox	botox/x.c	/^void _xReadInbox(System *sP) {$/;"	f
_xReadMessage	botox/x.c	/^static void _xReadMessage(System *sP, Message *msgP) {$/;"	f	file:
agentBbMP	botox/include/bt.h	/^  Map      *agentBbMP;     \/\/ maps an enum'd state name to a void pointer. Anything truly global should be accessed directly.$/;"	m	struct:__anon35
arrayDel	botox/data.c	/^void arrayDel(void **arryPP) {$/;"	f
arrayGetElemSz	botox/data.c	/^U32 arrayGetElemSz(const void *arryP) {$/;"	f
arrayGetNElems	botox/data.c	/^U32 arrayGetNElems(const void *arryP) {$/;"	f
arrayGetVoidElemPtr	botox/data.c	/^void* arrayGetVoidElemPtr(const void *arryP, S32 idx) {$/;"	f
arrayIni	botox/data.c	/^Error arrayIni(void **arryPP, HardCodedArray *hcaP) {$/;"	f
arrayIniPtrs	botox/data.c	/^void arrayIniPtrs(const void *arryP, void **startP, void **endP, S32 endIdx) {$/;"	f
arrayNew	botox/data.c	/^Error arrayNew(void **arryPP, U32 elemSz, U32 nElems) {$/;"	f
arrayP	botox/include/data.h	/^	void        *arrayP;       \/\/ defaults to NULL to prevent copies $/;"	m	struct:__anon39
arraySetVoidElem	botox/data.c	/^Error arraySetVoidElem(void *arrayP, U32 idx, const void *elemSrcompP) {$/;"	f
attn	botox/include/data.h	/^	Key attn;   \/\/ e.g. motion system's translate focus$/;"	m	struct:__anon45
bbDel	botox/bt.c	/^void bbDel(Blackboard **bbPP) {$/;"	f
bbIdx	framework/include/xGo.h	/^	Key bbIdx;$/;"	m	struct:__anon16
bbNew	botox/bt.c	/^Error bbNew(Blackboard **bbPP, Node *rootP, Key ownerId, BBSeed *bbSeedP) {$/;"	f
bbP	framework/include/xGo.h	/^	Blackboard *bbP;  \/\/ Why array of pointers and not BBs themselves? Because btRun() takes Blackboard*.$/;"	m	struct:__anon18
bbPA	framework/include/xGo.h	/^	Blackboard **bbPA;$/;"	m	struct:__anon20
biomeP	framework/include/xMain.h	/^	Biome *biomeP;$/;"	m	struct:__anon26
biomeP	framework/include/xMain.h	/^	Biome *biomeP;$/;"	m	struct:__anon27
biomeP	framework/include/xMain.h	/^	Biome *biomeP;$/;"	m	struct:__anon28
bitFlag_	botox/data.c	4;"	d	file:
bpp	xBuiltins/include/xRender.h	/^	U8 bpp;$/;"	m	struct:__anon8
btCondition	botox/include/bt.h	/^Node_(btCondition);   \/\/ easy-to-check condition (e.g. world state)$/;"	v
btDel	botox/bt.c	/^void btDel(BTree **treePP) {$/;"	f
btNew	botox/bt.c	/^Error btNew(SrcNode *srcNodeP, BTree **treePP) {$/;"	f
btP	framework/include/xGo.h	/^	BTree *btP;$/;"	m	struct:__anon16
btP	framework/include/xGo.h	/^	BTree *btP;$/;"	m	struct:__anon17
btRun	botox/bt.c	/^NodeStat btRun(BTree *treeP, Blackboard *bbP, Mailbox *outboxP) {$/;"	f
btSelector	botox/include/bt.h	/^Node_(btSelector);$/;"	v
btSequence	botox/include/bt.h	/^Node_(btSequence);$/;"	v
btXCondition	botox/include/bt.h	/^Node_(btXCondition);  \/\/ ECS-based condition$/;"	v
buttonsDown	xBuiltins/include/xControl.h	/^	U32 buttonsDown;$/;"	m	struct:__anon2
buttonsPressed	xBuiltins/include/xControl.h	/^	U32 buttonsPressed;$/;"	m	struct:__anon3
buttonsPressed	xBuiltins/xControl.c	/^U32 buttonsPressed;$/;"	v
byteIdx_	botox/data.c	3;"	d	file:
cbIdx	botox/include/x.h	/^  Bln    cbIdx;                 \/\/ index to FP instead of FP itself to prevent external functions$/;"	m	struct:__anon50
checkA	botox/include/x.h	/^  Check *checkA;$/;"	m	struct:__anon51
checkIdx	botox/include/x.h	/^  Key checkIdx;  \/\/ index of check$/;"	m	struct:__anon48
checkers	botox/include/x.h	/^  Checkers     checkers;            \/* Array of checks; similar to Focus without exlusive C-access *\/$/;"	m	struct:_System
childrenPA	botox/include/bt.h	/^  struct SrcNode **childrenPA;$/;"	m	struct:SrcNode	typeref:struct:SrcNode::SrcNode
clearScreen	engine/jbInterface.c	/^void clearScreen(Renderer_ *rendererP) {$/;"	f
colorA	xBuiltins/include/xRender.h	/^	Color_ *colorA;$/;"	m	struct:__anon9
colorMapP	xBuiltins/include/xRender.h	/^	Colormap *colorMapP;$/;"	m	struct:__anon9
compA	botox/include/x.h	/^  void *compA;         \/* components the above function operates on *\/$/;"	m	struct:_Focus
compDirectoryP	botox/include/x.h	/^  Map         *compDirectoryP;      \/* maps component IDs to an element in an array of CmpAddresses *\/$/;"	m	struct:_System
compIdx	botox/include/x.h	/^  Key compIdx;$/;"	m	struct:__anon48
compLocationP	botox/include/x.h	/^  struct Complocation *compLocationP;      \/\/ keep tabs on component's location$/;"	m	struct:__anon50	typeref:struct:__anon50::Complocation
compP	botox/include/x.h	/^  void *compP; \/* Systems that use pointers to other systems' components may use double pointers to avoid requesting updated info. *\/$/;"	m	struct:__anon48
compSz	botox/include/x.h	/^  Key          compSz;              \/* components are the same size in all of this system's activities *\/$/;"	m	struct:_System
compressedData	botox/include/data.h	/^	U8  compressedData[];$/;"	m	struct:__anon44
compressedLen	botox/include/data.h	/^	U32 compressedLen;$/;"	m	struct:__anon44
condition	botox/include/bt.h	/^  U8 condition;       \/\/ bit-flag conditions which must be met to run this node$/;"	m	struct:Node
condition	botox/include/bt.h	/^  U8 condition;$/;"	m	struct:SrcNode
conditionA	botox/include/bt.h	/^  U8 *conditionA;$/;"	m	struct:NodeA
conditionMP	botox/include/bt.h	/^  Map      *conditionMP;  \/\/ maps node indices to U32 condition flags specifically enumerated for the condition node$/;"	m	struct:__anon35
conditionP	botox/include/x.h	/^  U8    *conditionP;            \/\/ condition to update through a simple pointer$/;"	m	struct:__anon50
copy_	engine/include/jbInterface.h	13;"	d
count	framework/xMain.c	/^	Key count; $/;"	m	struct:__anon12	file:
ctrlListen	xBuiltins/xControl.c	/^Error ctrlListen(Focus *fP) {$/;"	f
dataP	xBuiltins/include/xRender.h	/^	U8 *dataP;    \/\/ JB only supports 8-bit colormap. If image requires neither strips nor bit-unpacking, this simply points at the inflatable data.$/;"	m	struct:__anon8
dstRectPP	xBuiltins/include/xRender.h	/^	Rect_ **dstRectPP;$/;"	m	struct:__anon10
dunnoYet	framework/include/xMain.h	/^} dunnoYet;$/;"	t	typeref:struct:__anon26
entity	botox/include/x.h	/^  Entity entity;                \/\/ entity this check regards$/;"	m	struct:__anon50
entity	framework/include/xGo.h	/^	Entity entity;$/;"	m	struct:__anon18
enumIndices_	botox/include/data.h	24;"	d
enumKeys_	botox/include/data.h	23;"	d
enumValA	botox/include/data.h	/^	EnumValPair  enumValA[];$/;"	m	struct:__anon39
firstChildIdx	botox/include/bt.h	/^  U8 firstChildIdx;$/;"	m	struct:Node
firstChildIdxA	botox/include/bt.h	/^  U8 *firstChildIdxA;$/;"	m	struct:NodeA
firstEmptyIdx	botox/include/x.h	/^  Key firstEmptyIdx;    \/* marks the first empty element's index *\/$/;"	m	struct:_Focus
firstEmptyIdx	botox/include/x.h	/^  Key firstEmptyIdx; \/* marks the first empty element's index *\/$/;"	m	struct:__anon51
firstInactiveActIdx	botox/include/x.h	/^  Key          firstInactiveActIdx; \/* index of first inactive focus *\/$/;"	m	struct:_System
firstInactiveIdx	botox/include/x.h	/^  Key firstInactiveIdx; \/* marks the first inactive element's index *\/$/;"	m	struct:_Focus
firstInactiveIdx	botox/include/x.h	/^  Key firstInactiveIdx; \/* marks the first inactive element's index *\/$/;"	m	struct:__anon51
flagA	botox/include/data.h	/^	FlagInfo flagA[N_FLAG_BYTES];  \/\/ "A" means "Array" for JB's naming standards $/;"	m	struct:__anon42
flags	botox/include/data.h	/^	Key flags;  $/;"	m	struct:__anon40
flipIdxA	xBuiltins/include/xRender.h	/^	U16 flipIdxA[];$/;"	m	struct:__anon5
flipSetP	xBuiltins/include/xRender.h	/^	FlipSet *flipSetP;$/;"	m	struct:__anon6
focusA	botox/include/x.h	/^  Focus       *focusA;              \/\/ array of individual tasks to focus on. Comps can only be active in one focus at a time.$/;"	m	struct:_System
focusDirectoryP	botox/include/x.h	/^  Map         *focusDirectoryP;      \/* maps component IDs to an element in an array of CmpAddresses *\/$/;"	m	struct:_System
focusFP	botox/include/x.h	/^  FocusFP focusFP;     \/* function that runs on these components *\/$/;"	m	struct:_Focus
focusID	botox/include/x.h	/^  Key focusID;$/;"	m	struct:__anon48
focusIdx	botox/include/x.h	/^  Key focusIdx;$/;"	m	struct:__anon49
focusP	botox/include/x.h	/^  Focus *focusP; \/* Systems that use pointers to other systems' components may use double pointers to avoid requesting updated info. *\/$/;"	m	struct:__anon49
geneClass	framework/include/xMain.h	/^	U8 geneClass;$/;"	m	struct:__anon22
geneClass	framework/xMain.c	/^	Key geneClass;$/;"	m	struct:__anon12	file:
genePA	framework/include/xMain.h	/^	GeneHeader *genePA[];$/;"	m	struct:__anon23
geneType	framework/xMain.c	/^	Key geneType;$/;"	m	struct:__anon12	file:
genomeP	framework/include/xMain.h	/^	Genome *genomeP;$/;"	m	struct:__anon24
getKeySymbol_	engine/include/jbInterface.h	22;"	d
guiNew	engine/jbInterface.c	/^Error guiNew(Window_ **windowPP, Renderer_ **rendererPP) {$/;"	f
h	xBuiltins/include/xRender.h	/^	U16 w, h, pitch;  \/\/ in pixel units; determine actual step size by pixel format$/;"	m	struct:__anon8
hcMapDel	botox/data.c	/^void hcMapDel(HardCodedMap *hcmP) {$/;"	f
hcMapIni	botox/data.c	/^Error hcMapIni(HardCodedMap *hcmP) {$/;"	f
hcMapNew	botox/data.c	/^Error hcMapNew(HardCodedMap *hcmP) {$/;"	f
hcmP	botox/include/x.h	/^  HardCodedMap *hcmP;  \/\/ Some types of components' values change under various circumstances.$/;"	m	struct:__anon48
hcompArrayIni	botox/data.c	/^Error hcompArrayIni(HardCodedArray *hcaP) {$/;"	f
histoDel	botox/data.c	/^void histoDel(U32 **histoPP) {$/;"	f
histoNew	botox/data.c	/^Error histoNew(U32 **histoPP, const U32 maxVal) {$/;"	f
hiveMindMP	framework/include/xGo.h	/^	Map         *hiveMindMP; \/\/ maps triggers to arrays of $/;"	m	struct:__anon20
id	botox/include/bt.h	/^	Key       id;$/;"	m	struct:__anon35
id	botox/include/x.h	/^  Key          id;                  \/* ID of focus *\/$/;"	m	struct:_System
id	botox/include/x.h	/^  Key id;$/;"	m	struct:_Focus
imgP	xBuiltins/include/xRender.h	/^	Image *imgP;$/;"	m	struct:__anon10
inboxP	botox/include/x.h	/^  Mailbox     *inboxP;               \/* Where commands come in from the outside world *\/$/;"	m	struct:_System
inboxRead	botox/include/data.h	/^typedef Error (*inboxRead)(Mailbox *mailboxP);  \/\/ only for self$/;"	t
inflate	botox/data.c	/^Error inflate(Inflatable *inflatableP) {$/;"	f
inflatedDataP	botox/include/data.h	/^	void *inflatedDataP;$/;"	m	struct:__anon44
inflatedLen	botox/include/data.h	/^	U32 inflatedLen;$/;"	m	struct:__anon44
inline	botox/include/data.h	21;"	d
jbAlloc	botox/data.c	/^inline Error jbAlloc(void **voidPP, U32 elemSz, U32 nElems) {$/;"	f
jbFree	botox/data.c	/^inline void jbFree(void **voidPP) {$/;"	f
key	botox/include/data.h	/^	Key key;$/;"	m	struct:__anon41
keyValA	botox/include/data.h	/^	KeyValPair  keyValA[];$/;"	m	struct:__anon43
keyValPairA	botox/include/bt.h	/^  KeyValPair *keyValPairA;$/;"	m	struct:__anon34
m_bit_buf	botox/data.c	/^  tinfl_bit_buf_t m_bit_buf;$/;"	m	struct:tinfl_decompressor_tag	file:
m_check_adler32	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_code_size	botox/data.c	/^  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];$/;"	m	struct:__anon32	file:
m_counter	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_dist	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_dist_from_out_buf_start	botox/data.c	/^  size_t m_dist_from_out_buf_start;$/;"	m	struct:tinfl_decompressor_tag	file:
m_final	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_len_codes	botox/data.c	/^  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];$/;"	m	struct:tinfl_decompressor_tag	file:
m_look_up	botox/data.c	/^  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];$/;"	m	struct:__anon32	file:
m_n_bits	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_num_extra	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_raw_header	botox/data.c	/^  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];$/;"	m	struct:tinfl_decompressor_tag	file:
m_state	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_table_sizes	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_tables	botox/data.c	/^  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_tree	botox/data.c	/^  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];$/;"	m	struct:__anon32	file:
m_type	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_z_adler32	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_zhdr0	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
m_zhdr1	botox/data.c	/^  mz_uint32 m_state, m_n_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];$/;"	m	struct:tinfl_decompressor_tag	file:
mailboxClr	botox/data.c	/^void mailboxClr(Mailbox *mailboxP) {$/;"	f
mailboxDel	botox/data.c	/^void mailboxDel(Mailbox **mailboxPP) {$/;"	f
mailboxNew	botox/data.c	/^Error mailboxNew(Mailbox **mailboxPP, Key ownerID, U16 nSlots) {$/;"	f
mailboxWrite	botox/data.c	/^Error mailboxWrite(Mailbox *mailboxP, Key to, Key attn, Key topic, Key msg) {$/;"	f
main	engine/jb.c	/^int main() {$/;"	f
mapA	botox/include/data.h	/^	void  *mapA;  $/;"	m	struct:__anon42
mapDel	botox/data.c	/^void mapDel(Map **mapPP) {$/;"	f
mapGet	botox/data.c	/^extern void* mapGet(const Map *mapP, const Key key) {$/;"	f
mapIni	botox/data.c	/^Error mapIni(Map **mapPP, HardCodedMap *hcMapP) {$/;"	f
mapNew	botox/data.c	/^Error mapNew(Map **mapPP, const U8 elemSz, const Key nElems) {$/;"	f
mapP	botox/include/data.h	/^	Map        *mapP;       \/\/ defaults to NULL to prevent copies $/;"	m	struct:__anon43
mapRem	botox/data.c	/^Error mapRem(Map *mapP, const Key key) {$/;"	f
mapSet	botox/data.c	/^Error mapSet(Map *mapP, const Key key, const void *valP) {$/;"	f
msg	botox/include/data.h	/^	Key msg;    \/\/ e.g. move entity 42 with key FAST_LEFT$/;"	m	struct:__anon45
msgA	botox/include/data.h	/^  Message *msgA;$/;"	m	struct:__anon46
mz_int16	botox/data.c	/^typedef signed short mz_int16;$/;"	t	file:
mz_uint	botox/data.c	/^typedef unsigned int mz_uint;$/;"	t	file:
mz_uint16	botox/data.c	/^typedef unsigned short mz_uint16;$/;"	t	file:
mz_uint32	botox/data.c	/^typedef unsigned int mz_uint32;$/;"	t	file:
mz_uint64	botox/data.c	/^typedef unsigned long long mz_uint64;$/;"	t	file:
mz_uint8	botox/data.c	/^typedef unsigned char mz_uint8;$/;"	t	file:
nArgs_	botox/include/data.h	25;"	d
nBBsSet	framework/include/xGo.h	/^	Key          nBBsSet;$/;"	m	struct:__anon20
nChildren	botox/include/bt.h	/^  U8 nChildren;$/;"	m	struct:SrcNode
nColors	xBuiltins/include/xRender.h	/^	U8 nColors;$/;"	m	struct:__anon9
nDistinctBbs	framework/xMain.c	/^  Key nDistinctBbs;$/;"	m	struct:__anon13	file:
nDistinctHivemindQuirks	framework/include/xGo.h	/^	Key nDistinctHivemindQuirks;$/;"	m	struct:__anon19
nDistinctIndividualQuirks	framework/include/xGo.h	/^	Key nDistinctIndividualQuirks;$/;"	m	struct:__anon19
nDistinctShareds	framework/xMain.c	/^  Key nDistinctShareds;$/;"	m	struct:__anon13	file:
nEntities	framework/include/xMain.h	/^  U32 nEntities;$/;"	m	struct:__anon25
nFlips	xBuiltins/include/xRender.h	/^	U16 nFlips;$/;"	m	struct:__anon5
nFocuses	botox/include/x.h	/^  Key          nFocuses;            \/* Number of activities in focusA[] *\/$/;"	m	struct:_System
nGenes	framework/include/xMain.h	/^  U8 nGenes;$/;"	m	struct:__anon23
nIndices	xBuiltins/include/xRender.h	/^	U16 nIndices;$/;"	m	struct:__anon7
nKeyValPairs	botox/include/bt.h	/^  U8 nKeyValPairs;$/;"	m	struct:__anon34
nMsgs	botox/include/data.h	/^  U16 nMsgs;$/;"	m	struct:__anon46
nQuirks	framework/include/xGo.h	/^	Key nQuirks;$/;"	m	struct:__anon15
nSeeds	framework/include/xGo.h	/^	Key nSeeds;$/;"	m	struct:__anon19
nStrips	xBuiltins/include/xRender.h	/^	U16 nStrips;    \/\/ number of 64-pixel strips in strip set$/;"	m	struct:__anon6
nSystems	framework/include/xMain.h	/^	U8 nSystems;$/;"	m	struct:__anon26
nSystems	framework/include/xMain.h	/^	U8 nSystems;$/;"	m	struct:__anon27
nSystemsMax	framework/include/xMain.h	/^	U8 nSystemsMax;$/;"	m	struct:__anon26
nSystemsMax	framework/include/xMain.h	/^	U8 nSystemsMax;$/;"	m	struct:__anon27
nextSiblingIdx	botox/include/bt.h	/^  U8 nextSiblingIdx;  \/\/ allows easy "while(nodeP->nextSibling)" condition-check$/;"	m	struct:Node
nextSiblingIdxA	botox/include/bt.h	/^  U8 *nextSiblingIdxA;  \/\/ allows easy "while(nodeP->nextSibling)" condition-check$/;"	m	struct:NodeA
nodeCb	botox/include/bt.h	/^  NodeCb nodeCb;      \/\/ because nobody points at root @ index 0 as sibling or child$/;"	m	struct:Node
nodeCb	botox/include/bt.h	/^  NodeCb nodeCb;$/;"	m	struct:SrcNode
nodeCbA	botox/include/bt.h	/^  NodeCb *nodeCbA;      \/\/ because nobody points at root @ index 0 as sibling or child$/;"	m	struct:NodeA
nodeStatA	botox/include/bt.h	/^  NodeStat *nodeStatA;  \/\/ tree node's status (complete, failed, running, error, etc.)$/;"	m	struct:__anon35
outboxP	botox/include/bt.h	/^	Mailbox  *outboxP;$/;"	m	struct:__anon35
outboxP	botox/include/x.h	/^  Mailbox     *outboxP;              \/* Where this system talks to the outside world *\/$/;"	m	struct:_System
outboxRead	botox/include/data.h	/^typedef Error (*outboxRead)(Mailbox *mailboxP);  \/\/ only of children$/;"	t
outputIfTrue	botox/include/x.h	/^  U8     outputIfTrue;          \/\/ condition flag to be OR'd into if true$/;"	m	struct:__anon50
owner	botox/include/x.h	/^  Entity owner;$/;"	m	struct:__anon47
ownerID	botox/include/data.h	/^	Key ownerID;$/;"	m	struct:__anon46
ownerP	botox/include/x.h	/^  struct _System *ownerP;$/;"	m	struct:_Focus	typeref:struct:_Focus::_System
personalityP	framework/include/xGo.h	/^	Personality *personalityP;$/;"	m	struct:__anon18
pitch	xBuiltins/include/xRender.h	/^	U16 w, h, pitch;  \/\/ in pixel units; determine actual step size by pixel format$/;"	m	struct:__anon8
pollEvent_	engine/include/jbInterface.h	17;"	d
preMapSet	botox/data.c	/^static Error preMapSet(const Map *mapP, const Key key, void **elemPP, void **nextElemPP, U32 *nBytesTMoveP) {$/;"	f	file:
present_	engine/include/jbInterface.h	14;"	d
prevBitCount	botox/include/data.h	/^	Key prevBitCount;$/;"	m	struct:__anon40
priority	framework/include/xGo.h	/^	U8 priority;$/;"	m	struct:__anon14
priority	framework/include/xGo.h	/^	U8 priority;$/;"	m	struct:__anon16
priority	framework/include/xGo.h	/^	U8 priority;$/;"	m	struct:__anon17
quirkPA	framework/include/xGo.h	/^	Quirk **quirkPA;$/;"	m	struct:__anon15
quit_	engine/include/jbInterface.h	19;"	d
reactionMP	framework/include/xMain.h	/^	Personality *reactionMP; $/;"	m	struct:__anon24
render	xBuiltins/xRender.c	/^Error render(Focus *fP) {$/;"	f
rendererP	xBuiltins/include/xRender.h	/^	Renderer_ *rendererP;$/;"	m	struct:__anon11
root	botox/include/x.h	/^  Key    root;                  \/\/ root of behavior tree to fire$/;"	m	struct:__anon50
rootP	botox/include/bt.h	/^  Node *rootP;$/;"	m	struct:__anon36
rootSrcP	botox/include/bt.h	/^	SrcNode *rootSrcP;$/;"	m	struct:__anon37
sClrFP	botox/include/x.h	/^  XClrFP       sClrFP;$/;"	m	struct:_System
sGetFocus	botox/x.c	/^Focus* sGetFocus(System *sP, Key focusID) {$/;"	f
sIniCompFP	botox/include/x.h	/^  XIniCompFP   sIniCompFP;             \/* Some systems need to inflate components before using them. *\/$/;"	m	struct:_System
sIniSParamsP	botox/include/x.h	/^  void        *sIniSParamsP;        \/* whatever sIniSysFP() needs to properly initialize this system *\/$/;"	m	struct:_System
sIniSysFP	botox/include/x.h	/^  XIniSFP      sIniSysFP;             \/* System init function pointer *\/$/;"	m	struct:_System
sProcessMessageFP	botox/include/x.h	/^  XProcMsgFP   sProcessMessageFP;   \/* What to do in response to commands in inbox messages. *\/$/;"	m	struct:_System
seedA	framework/include/xGo.h	/^	XGoIniSeed *seedA;$/;"	m	struct:__anon19
seedPA	framework/include/xMain.h	/^  Seed *seedPA[];$/;"	m	struct:__anon25
sharedMP	framework/include/xMain.h	/^	Map *sharedMP;         \/\/ map of maps of shared "components"$/;"	m	struct:__anon28
size	framework/include/xMain.h	/^	U8 size;$/;"	m	struct:__anon22
size	framework/xMain.c	/^	Key size;$/;"	m	struct:__anon12	file:
srcRectPP	xBuiltins/include/xRender.h	/^	Rect_ **srcRectPP;$/;"	m	struct:__anon10
stripMapInfP	xBuiltins/include/xRender.h	/^	Inflatable *stripMapInfP;$/;"	m	struct:__anon7
stripMapP	xBuiltins/include/xRender.h	/^	StripMap *stripMapP;$/;"	m	struct:__anon8
stripSetInfP	xBuiltins/include/xRender.h	/^	Inflatable *stripSetInfP;  \/\/ strip set's compressed source data$/;"	m	struct:__anon6
stripSetP	xBuiltins/include/xRender.h	/^	StripSet *stripSetP;$/;"	m	struct:__anon8
surfaceIni	engine/jbInterface.c	/^Error surfaceIni(Surface_ *surfaceP, XRenderComp *cP) {$/;"	f
surfaceNew	engine/jbInterface.c	/^Error surfaceNew(Surface_ **surfacePP, XRenderComp *cP) {$/;"	f
swapPlaceholderP	botox/include/x.h	/^  void        *swapPlaceholderP;    \/* Avoids allocating a new placeholder every EC-swap. *\/$/;"	m	struct:_System
sysPA	framework/include/xMain.h	/^	System **sysPA;$/;"	m	struct:__anon26
sysPA	framework/include/xMain.h	/^	System **sysPA;$/;"	m	struct:__anon27
system	framework/include/xGo.h	/^	System system;$/;"	m	struct:__anon20
system	framework/include/xMain.h	/^	System system;$/;"	m	struct:__anon28
system	xBuiltins/include/xControl.h	/^	System system;$/;"	m	struct:__anon3
system	xBuiltins/include/xRender.h	/^	System system;$/;"	m	struct:__anon11
textureDel	engine/jbInterface.c	/^void textureDel(Texture_ **texturePP) {$/;"	f
textureNew	engine/jbInterface.c	/^Error textureNew(Texture_ **texturePP, Renderer_ *rendererP, Surface_ *surfaceP) {$/;"	f
textureP	xBuiltins/include/xRender.h	/^	Texture_ *textureP;$/;"	m	struct:__anon9
textureSetAlpha	engine/jbInterface.c	/^Error textureSetAlpha(Texture_ *textureP) {$/;"	f
thisIdx	botox/include/bt.h	/^  U8 thisIdx;         \/\/ allows updating of its own NodeStat and for keying condition map$/;"	m	struct:Node
thisIdxA	botox/include/bt.h	/^  U8 *thisIdxA;         \/\/ allows updating of its own NodeStat and for keying condition map$/;"	m	struct:NodeA
tinflIni	botox/data.c	467;"	d	file:
tinfl_bit_buf_t	botox/data.c	/^  typedef mz_uint32 tinfl_bit_buf_t;$/;"	t	file:
tinfl_bit_buf_t	botox/data.c	/^  typedef mz_uint64 tinfl_bit_buf_t;$/;"	t	file:
tinfl_decompress	botox/data.c	/^tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)$/;"	f
tinfl_decompress_mem_to_heap	botox/data.c	/^void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags) {$/;"	f
tinfl_decompressor	botox/data.c	/^struct tinfl_decompressor_tag; typedef struct tinfl_decompressor_tag tinfl_decompressor;$/;"	t	typeref:struct:tinfl_decompressor_tag	file:
tinfl_decompressor_tag	botox/data.c	/^struct tinfl_decompressor_tag$/;"	s	file:
tinfl_get_adler32	botox/data.c	468;"	d	file:
tinfl_huff_table	botox/data.c	/^} tinfl_huff_table;$/;"	t	typeref:struct:__anon32	file:
tinfl_put_buf_func_ptr	botox/data.c	/^typedef int (*tinfl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);$/;"	t	file:
tinfl_status	botox/data.c	/^} tinfl_status;$/;"	t	typeref:enum:__anon30	file:
to	botox/include/data.h	/^	Key to;     \/\/ e.g. motion system$/;"	m	struct:__anon45
toggle	botox/include/x.h	/^  Bln    toggle;                \/\/ opposite of toggle is latch, in which case thee condition only needs to have been true once$/;"	m	struct:__anon50
topic	botox/include/data.h	/^	Key topic;  \/\/ e.g. this is for entity 42$/;"	m	struct:__anon45
treeP	botox/include/bt.h	/^	BTree *treeP;  \/\/ NULL if yet unimplemented.$/;"	m	struct:__anon37
treeSP	framework/include/xGo.h	/^	BTreeSingleton *treeSP;$/;"	m	struct:__anon14
trigger	framework/include/xGo.h	/^	Key trigger;$/;"	m	struct:__anon14
triggerMP	framework/include/xGo.h	/^	Map         *triggerMP;$/;"	m	struct:__anon20
type	botox/include/x.h	/^  U8 type;$/;"	m	struct:__anon47
type	framework/include/xMain.h	/^	U8 type;$/;"	m	struct:__anon22
unused_	botox/include/data.h	22;"	d
valP	botox/include/data.h	/^	void *valP;$/;"	m	struct:__anon38
valueP	botox/include/data.h	/^	void *valueP;$/;"	m	struct:__anon41
w	xBuiltins/include/xRender.h	/^	U16 w, h, pitch;  \/\/ in pixel units; determine actual step size by pixel format$/;"	m	struct:__anon8
windowP	xBuiltins/include/xRender.h	/^	Window_ *windowP;$/;"	m	struct:__anon11
xActivateComp	botox/x.c	/^Error xActivateComp(System *sP, Entity entity) {$/;"	f
xActivateFocus	botox/x.c	/^Error xActivateFocus(Focus *fP) {$/;"	f
xAddComp	botox/x.c	/^Error xAddComp(System *sP, Entity entity, XHeader *xhP) {$/;"	f
xCompIsActive	botox/x.c	/^U8 xCompIsActive(System *sP, Entity entity) {$/;"	f
xControlClr	xBuiltins/xControl.c	/^Error xControlClr(System *sP) {$/;"	f
xControlIniComp	xBuiltins/xControl.c	/^Error xControlIniComp(System *sP, XHeader *xhP) {$/;"	f
xControlIniSys	xBuiltins/xControl.c	/^Error xControlIniSys() {$/;"	f
xControlProcessMessage	xBuiltins/xControl.c	/^Error xControlProcessMessage(System *sP, Message *msgP) {$/;"	f
xDeactivateComp	botox/x.c	/^Error xDeactivateComp(System *sP, Entity entity) {$/;"	f
xDeactivateFocus	botox/x.c	/^Error xDeactivateFocus(Focus *fP) {$/;"	f
xGetComp	botox/x.c	/^void* xGetComp(System *sP, Entity entity) {$/;"	f
xGetCompMapP	botox/x.c	/^Map* xGetCompMapP(System *sP, Entity entity) {$/;"	f
xGetFocusFromE	botox/x.c	/^Focus* xGetFocusFromE(System *sP, Entity entity) {$/;"	f
xGetNComponents	botox/x.c	/^U32 xGetNComponents(System *sP) {$/;"	f
xGoClr	framework/xGo.c	/^void xGoClr(System *sP) {$/;"	f
xGoIniComp	framework/xGo.c	/^Error xGoIniComp(System *sP, XGoComp *cP) {$/;"	f
xGoIniSys	framework/xGo.c	/^Error xGoIniSys(System *sP, void *sParamsP) {$/;"	f
xGoProcessMessage	framework/xGo.c	/^Error xGoProcessMessage(System *sP, Message *msgP) {$/;"	f
xGoRun	framework/xGo.c	/^Error xGoRun(Focus *fP) {$/;"	f
xHeader	botox/include/x.h	/^  XHeader      xHeader;$/;"	m	struct:_System
xHeader	framework/include/xGo.h	/^	XHeader xHeader;$/;"	m	struct:__anon16
xHeader	xBuiltins/include/xControl.h	/^	XHeader xHeader;$/;"	m	struct:__anon2
xHeader	xBuiltins/include/xRender.h	/^	XHeader xHeader;$/;"	m	struct:__anon10
xIniCompMapP	botox/x.c	/^Error xIniCompMapP(System *sP, Entity entity) {$/;"	f
xIniFocus	botox/x.c	/^Error xIniFocus(System *sP, Focus *fP, U32 nComps) {$/;"	f
xIniFocusDirectory	botox/x.c	/^static Error xIniFocusDirectory(System *sP) {$/;"	f	file:
xIniSys	botox/x.c	/^Error xIniSys(System *sP, U32 nComps, void *miscP) {$/;"	f
xMainClr	framework/xMain.c	/^Error xMainClr(System *sP) {$/;"	f
xMainIni	framework/xMain.c	/^Error xMainIni(XMain **xMainSysPP, System **sPA, U16 nSystems, Key nSystemsMax, Biome *biomeP) {$/;"	f
xMainIniComp	framework/xMain.c	/^Error xMainIniComp(System *sP, XHeader *xhP) {$/;"	f
xMainIniSys	framework/xMain.c	/^Error xMainIniSys(System *sP, void *sParamsP) {$/;"	f
xMainProcessMessage	framework/xMain.c	/^Error xMainProcessMessage(System *sP, Message *msgP) {$/;"	f
xMainRunSystems	framework/xMain.c	/^static Error xMainRunSystems(Focus *fP) {$/;"	f	file:
xNewCompDirectory	botox/x.c	/^static Error xNewCompDirectory(System *sP, Key nElems) {$/;"	f	file:
xNewFocusDirectory	botox/x.c	/^static Error xNewFocusDirectory(System *sP) {$/;"	f	file:
xRenderClr	xBuiltins/xRender.c	/^Error xRenderClr(System *sP) {$/;"	f
xRenderIniComp	xBuiltins/xRender.c	/^Error xRenderIniComp(System *sP, XHeader *xhP) {$/;"	f
xRenderIniSys	xBuiltins/xRender.c	/^Error xRenderIniSys(System *sP, void *sParamsP) {$/;"	f
xRenderProcessMessage	xBuiltins/xRender.c	/^Error xRenderProcessMessage(System *sP, Message *msgP) {$/;"	f
xRun	botox/x.c	/^Error xRun(System *sP) {$/;"	f
xStartFocus	botox/x.c	/^Error xStartFocus(System *sP, Entity entity, Key dstFocusID) {$/;"	f
xheA	framework/xMain.c	/^  XHistoElem *xheA;$/;"	m	struct:__anon13	file:
xmsP	engine/jb.c	/^XMain *xmsP = NULL;$/;"	v

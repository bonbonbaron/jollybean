#ifndef ECS_H
#define ECS_H
#include "data.h"

/* Macros for Response, Response Sets, and Response Set Sequences */
#define RS_(...) {__VA_ARGS__, NULL}   /* Response Set (must be null-terminated) */
#define RS_SEQ_(...) {__VA_ARGS__, NULL}   /* Response Set Sequence (must be null-terminated) */
/* Macros for Behavior */
#define BEHAVIOR_(...) HARD_CODED_MAP_(void**, __VA_ARGS__)
#define RESPOND_TO_(key) {key, 
#define BY_(val) (void*) &val}
/* Macros for Personality */
#define PERSONALITY_(...) HARD_CODED_MAP_(void**, __VA_ARGS__)
#define IF_SCENE_TYPE_IS_(key) {key, 
#define BEHAVE_AS_(val) (void*) &val}
#define OTHERWISE_BEHAVE_AS_(val) {DEFAULT, (void*) &val}

/* Enums */
typedef enum {
	DIRECTOR_SYS_KEY,
	NUM_SYS_KEYS  // only used for creating system histograms
} SysKeys;

typedef enum {
	ENTITY,         // a message to an entity never directly reaches a system; the entity likely changes sequences
	COMPONENT,
	SYSTEM,
	NUM_ECS_TYPES   // probably never used
} ECSType;

typedef enum {
	IMMEDIATELY,
	AFTER_CURR_SYS
} MsgUrgency;

typedef enum {
  TOP_PRIORITY
} Priority;

typedef enum {
	SYSTEMWIDE_CMD,
	REPEATING_CMP_CMD,
	ONE_OFF_CMP_CMD
} CmdType;

typedef HardCodedMap Behavior;
typedef HardCodedMap Personality;

/**********/
/* Entity */
/**********/
typedef struct {
	Personality *personalityP;
	U8 *geneA[];  /* points at header of each gene; getGene() uses header to call the appropriate function,
									 which in turn casts it to the full gene type */
} EntitySeed;

typedef U8 Entity;  

/*************/
/* Component */
/*************/
/* Gene storage macros */
#define CMP_HEADER_(sysKey) {0, sysKey}
#define UNARY_GENE_(name_, cmpType_, ...) \
	cmpType_ name_##UVal = __VA_ARGS__;\
	UnaryGene name_##cmpType_##UGene = {\
		.type = UNARY,\
		.unaryP = &name_##UVal};

#define BINARY_GENE_(name_, cmpType_, tgtVal_, mask_, expVal_, ...) \
	cmpType_ name_##BA[2] = {__VA_ARGS__};\
	BinaryGene name_##cmpType_##BGene = {\
		.type    = BINARY,\
		.mask    = mask_,\
		.expVal  = expVal_,\
		.tgtP    = &tgtVal_,\
		.binaryA = name_##BA};

#define NONBINARY_GENE_(name_, cmpType_, globalStateKey_, ...) \
	KeyValPair name_##NKVA[] = {__VA_ARGS__};\
	NonbinaryGene name_##cmpType_##NGene  = {\
		.type    = NONBINARY,\
		._elemSz = sizeof(cmpType_),\
		._nElems = NUM_ARGS_(KeyValPair, __VA_ARGS__),\
		.keyP    = &globalStateKey_,\
		.mapP    = NULL,\
		.kvAP    = name_##NKVA};

#define GENE_(name_, type_, arity_) (U8*) &name_##type_##arity_##Gene 
#define RESPONSE_SET_(name) *name[]
#define RESPONSE_SEQUENCE_(name) **name[]
typedef enum {UNARY, BINARY, NONBINARY} _GeneType;

typedef void* (*GetGeneFP)(U8 *geneHeaderP, Key *overrideKeyP);

void* getUnaryGene(U8 *geneHeaderP, Key *overrideKeyP);
void* getBinaryGene(U8 *geneHeaderP, Key *overrideKeyP);
void* getNonbinaryGene(U8 *geneHeaderP, Key *overrideKeyP);

typedef struct {   /* 15 bytes */
	U8          type;
	U8          _elemSz;
	U8          _nElems;
	Key        *keyP;
	Map        *mapP;       /* defaults to NULL to prevent copies */
	KeyValPair *kvAP;        /* automagically generated via macro */
} NonbinaryGene;

typedef struct {  /* 11 bytes + padding */
	U8 type;
	U8 mask;        
	U8 expVal;       /* the masked data must equal expVal to index 1. Otherwise 0. */
	U8 *tgtP;
	void *binaryA;   /* automatically generated by macro */
} BinaryGene;

typedef struct {  /* 5 bytes + padding */
	U8 type;
	void *unaryP;
} UnaryGene;

typedef U8 CmpType;

typedef struct {
	Entity owner;   /* necessary to know what entity to affect */
	CmpType type;   /* necessary to know what system this component belongs to */
} CmpHeader;      /* size is inferred by system pointed to by type */

/**********/
/* System */
/**********/
struct _System;
struct _Activity;
typedef Error (*SysFP)(struct _System *sP, struct _Activity *aP, void *cmpA);
typedef Error (*SysIniFP)(struct _System *sP, void *cmpA);
typedef void (*SysBasicFP)(struct _System *sP);
typedef void (*SysOneOffFP)(struct _System *sP, Entity entity, U8 key);  /* optional key to a map or idx to array */

typedef struct {
	U8 activityIdx;
	U8 ecIdx;
  void *ecP;      /* Systems that use pointers to other systems' components may use double pointers to avoid requesting updated info. */
} ECLocation;

typedef enum {NO_OUTPUT, NUM_OUTPUTS} Output;
typedef struct {
	Key sysKey;
	U8  funcEnum;
	Key miscKey;
	Output  output;
} Response;

typedef struct {
	U8						 cmd;
	CmdType        cmdType;
	ECSType        toECSType;
	U32            toID;          /* id of recipient */
	U32            misc;          /* any miscellaneous content may be included here */
	MsgUrgency		 urgency;       /* speed at which message must reach its destination */
	Priority       priority;      /* priority which message command has over any existing component activity */
	void *paramsP;                /* Parameters for the target to pass to the cmd function... IF tgtECSType == SYSTEM. */
} Message;

typedef struct {
	Message *msgA;
	U32 nMsgs;
} Mailbox;

typedef struct _Activity {
	U8 active; /* boolean for whether this function should even operate */
	U8 firstInactiveIdx; /* marks the first inactive element's index */
	U8 firstEmptyIdx; /* marks the first empty element's index */
	SysFP sysFP; /* function that runs on these components */
	void *ecA;  /* components the above function operates on */
} Activity;

/* Systems are 100% modular by ignoring the outside world. They just react to their inboxes and fill their outboxes. */
typedef struct _System {
  U8           id;                /* this is needed to ensure messages are sent to the correct system */
	U8           active;            /* boolean for whether this syskem should even operate */
	U8           ecSz;              /* components are the same size in all of this system's activities */
  void        *swapPlaceholderP;  /* Avoids allocating a new placeholder every EC-swap. */
	Map         *ecLocationMapP;    /* maps component IDs to an element in an array of CmpAddresses */
	Activity    *activityA;         /* Array of activities that loop through their components */
	SysOneOffFP *oneOffFPA;         /* Array of one-off functions for system to perform one action immediately on an EC */
	Mailbox      inbox;             /* Where commands come in from the outside world */
	Mailbox      outbox;            /* Where this system talks to the outside world */
} System;

typedef enum {
	SYS_TOGGLE_ACTIVE,
	_MAX_SYSTEMWIDE_CMD_ID
} SysCmdID;


void sysToggleActive(System *sP);

void sysIniPtrs(System *sP, Activity *aP, void **startPP, void **endPP);
Error sysNew(System **sPP, U8 sysID, const U8 ecSz, U8 nFuncs);
void sysIni(System *sP, U8 sysID, SysFP *funcPtrA, U8 ecSz);
void sysDel(System **sPP);
#endif

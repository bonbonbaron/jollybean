#ifndef SYS_RENDER
#define SYS_RENDER
#include "botox.h"

#define WINDOW_KEY_ (1)
#define RENDERER_KEY_ (1)

#define N_PIXELS_PER_STRIP (32) 
#define N_BITS_IN_QUADWORD (128)
#define N_1BPP_PIXELS_PER_BYTE (8)
/* Words per strip math goes like this:
    # pixels    # bits    byte     word      # words
    -------- *  ------ * ------ * ------- =  -------
     strip       pixel   # bits   # bytes     strip
*/
#define N_WORDS_PER_1BPP_STRIP ((N_PIXELS_PER_STRIP * 1) >> 5)  
#define N_WORDS_PER_2BPP_STRIP ((N_PIXELS_PER_STRIP * 2) >> 5)  
#define N_WORDS_PER_4BPP_STRIP ((N_PIXELS_PER_STRIP * 4) >> 5)  
// Number of pixels per byte
#define N_1BPP_PIXELS_PER_BYTE (8)
#define N_2BPP_PIXELS_PER_BYTE (4)
#define N_4BPP_PIXELS_PER_BYTE (2)
// Masks used for grabbing 4 pixels in parallel. (That's why I stagger their order in img.c.)
#define MASK_1BPP  (0x01010101)
#define MASK_2BPP  (0x03030303)
#define MASK_4BPP  (0x0f0f0f0f)

typedef enum{WINDOW_GENE_TYPE = 1, RENDERER_GENE_TYPE, N_MASTER_GENES} GeneType;

typedef struct {
  U16 nFlips;
  U16 flipIdxA[];
} FlipSetS;

// Strip set's inflated data is in U32 format.
typedef struct {
  U8 nPixelsPerStrip;
  U16 nStrips;    // number of 64-pixel strips in strip set
  U32 nPixels
  FlipSetS *flipSetP;
  Inflatable *stripSetInfP;  // strip set's compressed source data
} StripSetS;

// StripMapS's inflated data is in U16 format.
typedef struct {
  U16 nIndices;
  Inflatable *stripMapInfP;
} StripMapS;

typedef struct {
  U8 bpp;
  U16 w, h, pitch;  // in pixel units; determine actual step size by pixel format
  StripSetS *stripSetP;
  StripMapS *stripMapP;
  U8 *dataP;    // JB only supports 8-bit colormap. If image requires neither strips nor bit-unpacking, this simply points at the inflatable data.
} ColormapS;     // When the inflatable requires neither unpacking nor strip-mapping, go ahead and memcpy over. I can't think of any cleaner way to do it.

// Backgrounds are made of tiles, although their source images are made of strips.  
// Therefore, the bg's ROM image is the tileset. The tileset gets compressed into
// strips just like all the other (foreground) images.
typedef struct {
  U32 tileDim;    // tiles are assumed to be square, so it's tile "dim" instead of width and height
  U32 nTilesHigh; // number of tiles high
  U32 nTilesWide; // number of tiles wide
  U16 *tileSetA;  // not to be confused with strip set
  U16 *tileMapA;  // not to be confused with strip map
} BgTilemap;

typedef struct {
  U8 nColors;
  U8 textureAtlasRectIdx;
  Color_ *colorA;
  ColormapS *colorMapP;
} XRenderCompSrc; 

typedef struct {
  Key srcRectIdx;
  Key dstRectIdx;
} XRenderComp;

// Images
Error cmGen(ColormapS *imgP);
void  cmClr(ColormapS *imgP);
Error xRenderIniS(System *sP, void *sParamsP);
Error xRenderProcessMessage(System *sP, Message *msgP);
typedef void (*XRenderPresentU)(Renderer_ *rendererP);
extern XRenderPresentU present;

typedef struct {
  System system;
  Window_ *windowP;
  Renderer_ *rendererP;
  Texture_ *textureP;
  Map *srcRectMAMP;  // Lets rendering system update the source rectangles' positions according to their placement in the texture atlas.
  Map *srcRectMP;   // Keeps rendering system posted on the animation frame of each animated entity.
  Map *dstRectMP;   // Keeps rendering system posted on the position and scale of each mobile entity.
  Map *xRenderCompSourceMP;
} XRender;

extern System *sRenderP;
#endif

PERSONALITIES:
	P {
		B { 
			T1 --> R1 {
				Step1 {
					{SysKey1, FuncEnum1, UniversalParam, Output}  <-- UniversalParam example: Key to animation strip in map of strips
					{SysKey2, FuncEnum2, UniversalParam, Output}
				},
				Step 2 {
					{SysKey3, FuncEnum3, UniversalParam, Output}
					{SysKey4, FuncEnum4, UniversalParam, Output}
					{SysKey5, FuncEnum5, UniversalParam, Output}
				},
				Step 3 {
					{SysKey6, FuncEnum6, UniversalParam, Output}
				}
			}
			T2 --> R2 {
				Step 1 {
					{SysKey7, FuncEnum7, UniversalParam, Output}
					{SysKey8, FuncEnum8, UniversalParam, Output}
				}
			}
		}
		B2...
		etc.
	}

	Keys seem all-powerful! So cool!

	So it's settled: Parameters go together with their functions for clarity. Genes are really just components (except for inflatable media). I would like for these personalities to be stored in one place as well instead of copied. That way everybody who uses them points at them.   

GENES
	This is the tricky part: making an entity have all kinds of components in an easy, organized way. E1 can have animation, motion, image, and control. What's an easy way to do that? 

	Entity { 
		Genes {
			&CMotion ({SysKey, component size, void pointer to component} (Use sizeof() since sub-arrays are in same file.)
			&CAnimation ({SysKey, component size, void pointer to component} (Use sizeof() since sub-arrays are in same file.)
			&CImage ({SysKey, component size, void pointer to component} (Use sizeof() since sub-arrays are in same file.)
			&CControl ({SysKey, component size, void pointer to component} (Use sizeof() since sub-arrays are in same file.)
			NULL
		}
		&personality
	}


	Then you iterate through the genes and send each system the component.
	Entity is a struct of Gene and Personality pointers. This fact determines my road map:

	TEST each one before moving on to the next one:
		Enum system keys (for director to check whether they've been created yet)
			System (generic)
				Director system with populated struct, functions, and enums
					A more specific system with populated struct, functions, and enums
		Component (arbitrary, choose anything to test on. Most rewarding would be image)
			Gene struct (e.g. Velocity, Image, etc.)
				Trigger enum
					Response struct
						Behavior struct
							Personality struct
								Entity struct
									Decide how positions will be apportioned... 


What about components that have multiple parts? Motion has multiple parts; so does animation, and the number of parts varies from entity to entity. Therefore, I need to be able to construct maps easily of these parts. 

What happens when someone passes a key to part of the map inside of a system? e.g. I've been walking left, and now I want to jump up. In the animation system, this is a matter of replacing the entire animation inside the animation loop with the jumping animation. This is how multiple entities can share data without having multiple copies of the same map everywhere; they only copy pieces of that map to each slot in the component array. (A system like animation will only have one function.)

What about walking left then walking right? I pass the K_CMP_WALK_RIGHT key for E1 in K_SYS_MOTION, the system accesses the map the component has a pointer to and replaces the components data with the returned value. The system stores the current address of the component in its bowels. After you get the value, you get the component's address with its ID (an ID key incremented system-wide at load-time) and stick the value there. No maps are copied. Ever. 

Are there any components that won't use maps? Velocity and animation will. Battle moves will too; they contain sequence keys. Battle stats won't. Images won't. Audio will; things like "K_TAKE_DAMAGE" triggers a roar from one monster and a low "ARGH" from a grown, male human. 

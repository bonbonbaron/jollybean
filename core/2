#include "xMain.h"
//***************************************************
//** System systems *********************************
//***************************************************
static Error xMainRunSystems(Focus *fP);
static Error xMainRunTasks(Focus *fP);
//static Map **_entityReactionMA;

typedef struct {
	U8 size;
	U8 count; 
	U8 type;
	U8 geneClass;
} XHistoElem;

// =====================================================================
// Loop through each genome's genes and histogram their component types.
// =====================================================================
static Error _histoGeneTypes(XHistoElem *metaA, Biome *biomeP) {
	if (!metaA || !biomeP)
		return E_BAD_ARGS;

	Seed **seedPP = biomeP->seedPA;
	Seed **seedEndPP = seedPP + biomeP->nEntities;   // pointer to the end of the above array
	Genome *genomeP;
	GeneHeader **ghPP, **ghEndPP;   // pointers to an array of gene header pointers and its end
	GeneHeader gh;  // faster access to double pointer'd gene header
	// Loop through genomes
	for (; seedPP < seedEndPP; seedPP++) {
		genomeP = (*seedPP)->genomeP;
		ghPP = &genomeP->genePA[0];
		ghEndPP = ghPP + genomeP->nGenes;
		// Histo genome's genes that aren't blackboard items.
		for (; ghPP < ghEndPP; ghPP++) {
			gh = **ghPP;
			if (gh.geneClass != BLACKBOARD) {
				metaA[gh.type].count++;
				metaA[gh.type].size = gh.size;
				metaA[gh.type].geneClass = gh.geneClass;
			}
		}
	}
	return SUCCESS;
}

// =====================================================================
// Distribute all genes to their appropriate subsystems.
// =====================================================================
static Error _distributeGenes(XMainSystem *xMainSysP, U8 nSystemsMax, Biome *biomeP) {
	Seed **seedPP = biomeP->seedPA;
	Seed **seedEndPP = seedPP + biomeP->nEntities;   // pointer to the end of the above array
	Genome *genomeP;
	GeneHeader **ghPP, **ghEndPP;   // pointers to an array of gene header pointers and its end
	GeneHeader gh;  // faster access to double pointer'd gene header
	XHeader xh = {0};
	U8 componentType;
	System *sP = NULL;
	Error e = SUCCESS;
	
	// Loop through seeds
	for (Entity entityCounter = nSystemsMax; !e && seedPP < seedEndPP; seedPP++, entityCounter++) {
		genomeP = (*seedPP)->genomeP;
		ghPP = (*seedPP)->genomeP->genePA;
		ghEndPP = ghPP + genomeP->nGenes;
		// Loop through current genome's genes
		for (; !e && ghPP < ghEndPP; ghPP++) {  // ghPP is a pointer to a pointer to a global singleton of a component
			gh = **ghPP;
			switch (gh.geneClass) {
				case ECS_COMPONENT:
					componentType = (*ghPP)->type;
					sP = (System*) xGetComp(sP, componentType);  // We don't set the owner of the gene pool.
					if (sP) {
						xh.type = componentType;
						e = xAddComp(sP, entityCounter, &xh);
					}
					break;
				case ECS_SHARED:
					e = mapSet(xMainSysP->sharedMP, gh.type, (const void*) *ghPP);  //*ghPP expands out to the size of the gene.
					break;
				case BLACKBOARD:

					break;
				default:
					break;
			}
		}
	}
	return e;
}

// =====================================================================
// Initialize the System system.
// =====================================================================
Error xMainIniSys(System *sP, void *sParamsP) {
	XMainIniSysPrms *xMainIniSysPrmsP = (XMainIniSysPrms*) sParamsP;
	U8 nSystemsMax = xMainIniSysPrmsP->nSystemsMax;
	U8 nSharedMaps = 0;
	XHistoElem xHistoA[nSystemsMax];
	XHistoElem *xheP, *xheEndP;
	XMainSystem *xMainSysP = (XMainSysP*) sP;

	if (!sParamsP)
		return E_BAD_ARGS;

	memset((void*) xHistoA, 0, nSystemsMax * sizeof(XHistoElem));

	Error e = _histoGeneTypes(&xHistoA[0], xMainIniSysPrmsP->biomeP);
	
	/****************************************
	************* ECS Components  ***********
	****************************************/
	// Add subsystems as components to System system.
	if (xMainIniSysPrmsP-)
		for (U32 i = 0; !e && i < xMainIniSysPrmsP->nSystems; i++) 
			if (xMainIniSysPrmsP->sysPA[i])
				e = xAddComp(sP, xMainIniSysPrmsP->sysPA[i]->id, &_sPA[i]->xHeader);

	// Initialize subsystems before we throw genes in.
	if (!e) {
		xheP = &xHistoA[0];
		xheEndP = xHistoA + nSystemsMax;
		for (Entity sID = 0; !e && xheP < xheEndP; xheP++, sID++) 
			if (xheP->geneClass == ECS_COMPONENT && xheP->count)  {  // i.e. if any entities exist having components for this system...
				System *_sP = (System*) xGetComp(sP, sID);
				if (sP)
					e = sIni(sP, xheP->count, sP->sIniSParamsP);  // makes subsystem's component directory and activities
			}
	}

	/******************************************
	************* Shared Components ***********
	******************************************/
	// Count the number of TYPES of shared items. 
	if (!e) {
		xheP = &xHistoA[0];
		xheEndP = xHistoA + nSystemsMax;
		for (; !e && xheP < xheEndP; xheP++)
			if (xheP->geneClass == ECS_SHARED && xheP->count)
				++nSharedMaps;
	}

	// Allocate map of maps.
	if (!e && nSharedMaps)
		e = mapNew(&_sharedMP, sizeof(Map), nSharedMaps);

	// Make a map of maps, one for each type (one map of positions, another of texts, etc.)
	// If you needed to make a shared map, then fill it. 
	if (!e && _sharedMP) {
		xheP = &xHistoA[0];
		xheEndP = xHistoA + nSystemsMax;
		Map *mapP = NULL;
		for (; !e && xheP < xheEndP; xheP++)
			if (xheP->geneClass == ECS_SHARED && xheP->count) {
				e = mapNew(&mapP, xheP->size, xheP->count);
				if (!e)
					e = mapSet(_sharedMP, xheP->type, (void*) mapP);
			}
	}

	/***************************************
	************* Behavior Trees ***********
	***************************************/
	if (!e) {
		Seed **seedPP = xMainIniSysPrmsP->biomeP->seedPA;
		Seed **seedEndPP = seedPP + xMainIniSysPrmsP->biomeP->nEntities;
		Genome *genomeP;
		GeneHeader **ghPP, **ghEndPP;   // pointers to an array of gene header pointers and its end
		GeneHeader gh;  // faster access to double pointer'd gene header
		Error e = SUCCESS;
		// Loop through seeds
		for (; !e && seedPP < seedEndPP; seedPP++) {
			genomeP = (*seedPP)->genomeP;
			ghPP = (*seedPP)->genomeP->genePA;
			ghEndPP = ghPP + genomeP->nGenes;
			// Loop through current genome's genes
			for (System *sP = NULL; !e && ghPP < ghEndPP; ghPP++) {  // ghPP is a pointer to a pointer to a global singleton of a component
				continue;  // TODO
			}
		}
	}

	/************************************
	************* Blackboards ***********
	************************************/
	//TODO btNew() all tree singletons
	//TODO allocate array of blackboards with # elems = # entities
	

	// ===========================================
	// Distribute the genes to the proper systems.
	// ===========================================
	if (!e)
		e = _distributeGenes(&sSystem, nSystemsMax, xMainIniSysPrmsP->biomeP);

	return e;
}

// ====================================================================================
// Placeholder for component-initialization; this has to be handled in xSystemIniS().
// ====================================================================================
Error xMainIniComp(XHeader *xhP) {
	unused_(xhP);
	return SUCCESS;
}


// This runs System's subsystems.
static Error xMainRunSystems(Focus *fP) {
	assert(fP);
	XSystemC *cP, *cEndP;
	Error e = SUCCESS;
	arrayIniPtrs(fP->cA, (void**) &cP, (void**) &cEndP, fP->firstInactiveIdx);
	for (cP = fP->cA; !e && cP < cEndP; cP++) {
		e = sRun(cP);
		// Put idle systems to sleep.
		if (!e && cP->firstInactiveActIdx == 0)
			e = xDeactivateComp(fP->, cP->id);
	}
	return e;
}

/* xIni() initializes the parent system as well as its children. */
Error xMainIni(System **sPA, U16 nSystems, U8 nSystemsMax, Biome *biomeP) {
	if (!sPA || nSystems < 1 || !biomeP)
		return E_BAD_ARGS;

	XMainIniSysPrms xMainSysIniPrms = {
		.nSystemsMax = nSystemsMax,
		.nSystems = nSystems,
		.biomeP = biomeP,
		.sysPA = sPA
  };

	return xIniSys(&sSystem, nSystems, (void*) &xMainSysIniPrms);
	// TODO: kick off the parent system activities here
}

typedef System XSysC;

System_(Sys, SYSTEM, Focus_(0, sRun));
